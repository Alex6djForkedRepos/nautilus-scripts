#!/usr/bin/env bash

IFS=$'\n'
ERROR_LOG_FILE="errors.log"

_msg_error() {
    MESSAGE="$1"

    # Check if the script is running in a terminal
    if env | grep -q '^TERM'; then
        echo >&2 "$MESSAGE"
    else # It not use gui notifications
        if hash notify-send 2>/dev/null; then
            notify-send -i error "$MESSAGE"
        elif hash zenity 2>/dev/null; then
            zenity --error --width=300 --text "$MESSAGE"
        elif hash kdialog 2>/dev/null; then
            kdialog --title "$MESSAGE" --passivepopup "This popup will disappear in 5 seconds" 5 &
        elif hash xmessage 2>/dev/null; then
            xmessage "$MESSAGE" -timeout 5
        fi
    fi
}

_msg_info() {
    MESSAGE="$1"

    # Check if the script is running in a terminal
    if env | grep -q '^TERM'; then
        echo "$MESSAGE"
    else # It not use gui notifications
        if hash notify-send 2>/dev/null; then
            notify-send "$MESSAGE"
        elif hash zenity 2>/dev/null; then
            zenity --info --width=300 --text "$MESSAGE"
        elif hash kdialog 2>/dev/null; then
            kdialog --title "$MESSAGE" --passivepopup "This popup will disappear in 5 seconds" 5 &
        elif hash xmessage 2>/dev/null; then
            xmessage "$MESSAGE" -timeout 5
        fi
    fi
}

_check_dependency() {
    LIST="$1"

    for LIST; do
        hash "$LIST" 2>/dev/null || {
            _msg_error "Could not find the command '$LIST'. Please, install it."
            exit 1
        }
    done
}

_remove_extension() {
    FILENAME="$1"
    # shellcheck disable=SC2001
    echo "$FILENAME" | sed "s|\.[^.]*$||"
}

_log_error() {
    FILENAME="$1"
    MESSAGE="$2"
    OUTPUT_DIR="$3"

    {
        echo "$(date "+%Y-%m-%d %H:%M:%S:") Error processing '$FILENAME'."
        echo "$MESSAGE"
        echo ""
    } >>"$OUTPUT_DIR/$ERROR_LOG_FILE"
}

_display_result() {
    ERROR_COUNT="$1"
    OUTPUT_DIR="$2"

    # Check if there was some error
    if ((ERROR_COUNT > 0)); then
        _msg_error "Task finished with errors! See the '$ERROR_LOG_FILE' for details."
        exit 1
    fi

    # If OUTPUT_DIR parameter is defined
    if [ -n "$OUTPUT_DIR" ]; then
        # Try remove output dir if it is empty
        rmdir "$OUTPUT_DIR" &>/dev/null

        # Check if output directory still exists
        if [ ! -d "$OUTPUT_DIR" ]; then
            _msg_info "Task finished, but there is no output files!"
            exit 0
        fi
        _msg_info "Task finished! The output is in: '$OUTPUT_DIR'."
    else
        _msg_info "Task finished!"
    fi
}

_get_output_dir() {
    DIR_NAME="output"
    DIR_BASE="$PWD"
    DIR_SUFFIX=1
    OUTPUT_DIR="$DIR_BASE/$DIR_NAME"

    [[ ! -w "$DIR_BASE" ]] && DIR_BASE="$HOME"
    [[ ! -w "$DIR_BASE" ]] && DIR_BASE="/tmp"

    if [[ ! -w "$DIR_BASE" ]]; then
        _msg_error "It was not possible to find directory with write permission."
        exit 1
    fi

    while [ -d "$OUTPUT_DIR" ]; do
        DIR_SUFFIX=$((DIR_SUFFIX + 1))
        OUTPUT_DIR="$DIR_BASE/$DIR_NAME$DIR_SUFFIX"
    done

    mkdir "$OUTPUT_DIR"
    echo "$OUTPUT_DIR"
}

_check_files() {
    INPUT_FILES="$1"
    MIME_LIST="$2"
    MIN_FILES="$3"
    MAX_FILES="$4"
    INCLUDE_DIRECTORIES="$5"

    OUTPUT_FILES=""
    FILES_COUNT=0
    for FILE in $INPUT_FILES; do
        VALID_FILE=0

        # Filter files by mime type
        if [ -n "$MIME_LIST" ]; then
            MIME_FILE=$(file --mime-type -b "$FILE")
            IFS_OLD=$IFS
            IFS=";"
            for MIME in $MIME_LIST; do
                [[ "$MIME_FILE" == *"$MIME"* ]] && VALID_FILE=1
            done
            IFS=$IFS_OLD
        else
            VALID_FILE=1
        fi

        # Exclude directories if INCLUDE_DIRECTORIES is empty
        if [ -z "$INCLUDE_DIRECTORIES" ]; then
            [ -d "$FILE" ] && VALID_FILE=0
        fi

        # Add the file in the list if it is valid
        if ((VALID_FILE == 1)); then
            FILES_COUNT=$((FILES_COUNT + 1))
            OUTPUT_FILES+="$FILE"
            OUTPUT_FILES+=$'\n'
        fi
    done

    # Check if there is at last one file with valid mime type
    if ((FILES_COUNT == 0)); then
        if [ -n "$MIME_LIST" ]; then
            _msg_error "There is no '$MIME_LIST' in the selected files!"
        else
            _msg_error "There is no valid itens in the in the selected files!"
        fi
        return 1
    fi

    if [ -n "$MIN_FILES" ]; then
        if ((FILES_COUNT < MIN_FILES)); then
            _msg_error "$FILES_COUNT file was selected, but the minium is $MIN_FILES!"
            return 1
        fi
    fi

    if [ -n "$MAX_FILES" ]; then
        if ((FILES_COUNT > MAX_FILES)); then
            _msg_error "$FILES_COUNT file was selected, but the maximum is $MAX_FILES!"
            return 1
        fi
    fi

    echo "$OUTPUT_FILES" | sort
    return 0
}
