#!/usr/bin/env bash

IFS=$'\n'
ERROR_LOG_FILE="errors.log"

_msg_error() {
    local MESSAGE="$1"

    # Check if the script is running in a terminal
    if env | grep -q '^TERM'; then
        echo >&2 "$MESSAGE"
    else # It doesn't use GUI notifications
        if hash notify-send 2>/dev/null; then
            notify-send -i error "$MESSAGE"
        elif hash zenity 2>/dev/null; then
            zenity --error --width=300 --text "$MESSAGE"
        elif hash kdialog 2>/dev/null; then
            kdialog --title "$MESSAGE" --passivepopup "This popup will disappear in 5 seconds" 5 &
        elif hash xmessage 2>/dev/null; then
            xmessage "$MESSAGE" -timeout 5
        fi
    fi
}

_msg_info() {
    local MESSAGE="$1"

    # Check if the script is running in a terminal
    if env | grep -q '^TERM'; then
        echo "$MESSAGE"
    else # If not, use GUI notifications
        if hash notify-send 2>/dev/null; then
            notify-send "$MESSAGE"
        elif hash zenity 2>/dev/null; then
            zenity --info --width=300 --text "$MESSAGE"
        elif hash kdialog 2>/dev/null; then
            kdialog --title "$MESSAGE" --passivepopup "This popup will disappear in 5 seconds" 5 &
        elif hash xmessage 2>/dev/null; then
            xmessage "$MESSAGE" -timeout 5
        fi
    fi
}

_check_dependencies() {
    local LIST_COMMANDS="$1"
    local PACKAGE_NAME=""
    local COMMAND=""

    for COMMAND in $LIST_COMMANDS; do
        if hash "$COMMAND" 2>/dev/null; then
            continue
        fi

        case "$COMMAND" in
        "cmp")
            PACKAGE_NAME="diffutils"
            ;;
        "convert")
            PACKAGE_NAME="imagemagick"
            ;;
        "file-roller")
            PACKAGE_NAME="file-roller"
            ;;
        "gs")
            PACKAGE_NAME="ghostscript"
            ;;
        "inkscape")
            PACKAGE_NAME="inkscape"
            ;;
        "jpegoptim")
            PACKAGE_NAME="jpegoptim"
            ;;
        "lame")
            PACKAGE_NAME="lame"
            ;;
        "latexmk")
            PACKAGE_NAME="latexmk"
            ;;
        "meld")
            PACKAGE_NAME="meld"
            ;;
        "7z")
            PACKAGE_NAME="p7zip-full"
            ;;
        "qpdf")
            PACKAGE_NAME="qpdf"
            ;;
        "zenity")
            PACKAGE_NAME="zenity"
            ;;
        "zip")
            PACKAGE_NAME="zip"
            ;;
        "iconv")
            PACKAGE_NAME="libc-bin"
            ;;
        "pandoc")
            PACKAGE_NAME="pandoc"
            ;;
        "perl")
            PACKAGE_NAME="perl-base"
            ;;
        "pdfimages" | "pdfseparate" | "pdftoppm" | "pdftotext" | "pdfunite")
            PACKAGE_NAME="poppler-utils"
            ;;
        "pdfjam")
            PACKAGE_NAME="texlive-extra-utils"
            ;;
        *)
            PACKAGE_NAME=""
            ;;
        esac

        if [ -n "$PACKAGE_NAME" ]; then
            _msg_error "Error: The command '$COMMAND' was not found. You need to install the '$PACKAGE_NAME' package."
        else
            _msg_error "Error: The command '$COMMAND' was not found. Please, install it."
        fi
        return 1
    done

    return 0
}

_get_filename_without_extension() {
    local FILENAME="$1"

    # shellcheck disable=SC2001
    echo "$FILENAME" | sed "s|\.[^.]*$||"
}

_get_filename_extension() {
    local FILENAME="$1"

    # shellcheck disable=SC2001
    echo "$FILENAME" | sed "s|^.*\.|.|"
}

_log_error() {
    local ERROR_TYPE="$1"
    local FILENAME="$2"
    local STD_OUTPUT="$3"
    local OUTPUT_DIR="$4"

    {
        echo "[$(date "+%Y-%m-%d %H:%M:%S")] ERROR while processing '$FILENAME'."
        echo -e "\tType: $ERROR_TYPE."
        echo -e "\tStandard output: $STD_OUTPUT"
        echo ""
    } >>"$OUTPUT_DIR/$ERROR_LOG_FILE"
}

_log_result_error() {
    local FILENAME="$1"
    local STD_OUTPUT="$2"
    local OUTPUT_DIR="$3"
    local EXIT_CODE="$4"
    local OUTPUT_FILE="$5" # To check if output file has zero bytes

    # Check the 'EXIT_CODE' and log the error
    if [ "$EXIT_CODE" -ne 0 ]; then
        _log_error "Exit code error" "$FILENAME" "$STD_OUTPUT" "$OUTPUT_DIR"
        return 1
    fi

    # Check if there is the word "Error" in stdout
    if [[ "${STD_OUTPUT,,}" == *"error"* ]]; then
        _log_error "Error in output message" "$FILENAME" "$STD_OUTPUT" "$OUTPUT_DIR"
        return 1
    fi

    # Check if output file exists
    if [[ -n "$OUTPUT_FILE" ]] && ! [ -f "$OUTPUT_FILE" ]; then
        _log_error "Output not exists" "$FILENAME" "$STD_OUTPUT" "$OUTPUT_DIR"
        return 1
    fi

    # Check if output file is not a zero byte
    if [ "$(stat --printf="%s" "$OUTPUT_FILE")" == "0" ]; then
        _log_error "Zero byte file" "$FILENAME" "$STD_OUTPUT" "$OUTPUT_DIR"
        return 1
    fi

    return 0
}

_display_result() {
    local OUTPUT_DIR="$1"
    local OUTPUT_DIR_PRINT="$OUTPUT_DIR"

    # Print a simplified $OUTPUT_DIR to the user
    echo "$OUTPUT_DIR_PRINT" | grep -q "$PWD" && OUTPUT_DIR_PRINT="./${OUTPUT_DIR#$PWD/}"
    # shellcheck disable=SC2088
    echo "$OUTPUT_DIR_PRINT" | grep -q "$HOME" && OUTPUT_DIR_PRINT="~/${OUTPUT_DIR#$HOME/}"

    # Check if there was some error
    if [ -f "$OUTPUT_DIR/$ERROR_LOG_FILE" ]; then
        _msg_error "Task finished with errors! See the '$OUTPUT_DIR_PRINT/$ERROR_LOG_FILE' for details."
        return 1
    fi

    # If OUTPUT_DIR parameter is defined
    if [ -n "$OUTPUT_DIR" ]; then
        # Try to remove the output directory (if it is empty)
        rmdir "$OUTPUT_DIR" &>/dev/null

        # Check if output directory still exists
        if [ -d "$OUTPUT_DIR" ]; then
            _msg_info "Task finished! The output files is in '$OUTPUT_DIR_PRINT' directory."
        else
            _msg_info "Task finished, but there is no output files!"
        fi
    else
        _msg_info "Task finished!"
    fi
}

_get_output_dir() {
    local DIR_NAME="output"
    local DIR_BASE="$PWD"
    local OUTPUT_DIR=""
    local DIR_SUFFIX=1

    # Check directories available to put the 'output' dir
    [[ ! -w "$DIR_BASE" ]] && DIR_BASE="$HOME"
    [[ ! -w "$DIR_BASE" ]] && DIR_BASE="/tmp"
    OUTPUT_DIR="$DIR_BASE/$DIR_NAME"

    if [[ ! -w "$DIR_BASE" ]]; then
        _msg_error "Error: Could not find a directory with write permissions."
        return 1
    fi

    # If there is a 'output' directory, try to use 'output-1', 'output-2', ...
    while [ -d "$OUTPUT_DIR" ]; do
        DIR_SUFFIX=$((DIR_SUFFIX + 1))
        OUTPUT_DIR="$DIR_BASE/$DIR_NAME$DIR_SUFFIX"
    done

    mkdir -p "$OUTPUT_DIR"
    echo "$OUTPUT_DIR"

    return 0
}

_get_files() {
    local INPUT_FILES="$1" # Input list
    local MIME_LIST="$2"   # Filter by MIME type
    local MIN_FILES="$3"   # Minimum number of valid files
    local MAX_FILES="$4"   # Maximum number of valid files
    local DIRECTORY_FLAG="$5"
    # DIRECTORY_FLAG values:
    # "d": Include directories.
    # "r": Expand directories recursively (include only files).
    # "R": Expand directories recursively (include files + subdirectories).
    # empty: Ignore directories.

    local FILE=""
    local INPUT_FILES_NEW=""
    local MIME_FILE=""
    local MIME=""
    local OUTPUT_FILES=""
    local VALID_FILE=0
    local VALID_FILES_COUNT=0

    # Expand files in directories recursively
    if [ "$DIRECTORY_FLAG" = "r" ] || [ "$DIRECTORY_FLAG" = "R" ]; then
        INPUT_FILES_NEW=""
        for FILE in $INPUT_FILES; do
            if [ "$DIRECTORY_FLAG" = "r" ]; then
                INPUT_FILES_NEW+="$(find -L "$FILE" -type f -not -path "*.git/*")"
            else
                INPUT_FILES_NEW+="$(find -L "$FILE" -not -path "*.git/*")"
            fi
            INPUT_FILES_NEW+=$'\n'
        done
        INPUT_FILES="$INPUT_FILES_NEW"
    fi

    # Checks if each file is valid
    for FILE in $INPUT_FILES; do
        VALID_FILE=0

        # Filter files by mime type
        if [ -n "$MIME_LIST" ]; then
            MIME_FILE=$(file --mime-type -b "$FILE")
            IFS_OLD=$IFS
            IFS=";"
            for MIME in $MIME_LIST; do
                [[ "$MIME_FILE" == *"$MIME"* ]] && VALID_FILE=1
            done
            IFS=$IFS_OLD
        else
            VALID_FILE=1
        fi

        # Check the DIRECTORY_FLAG
        if [ -d "$FILE" ]; then
            [ -n "$DIRECTORY_FLAG" ] && VALID_FILE=1
        fi

        # Add the file in the list if it is valid
        if ((VALID_FILE == 1)); then
            VALID_FILES_COUNT=$((VALID_FILES_COUNT + 1))
            OUTPUT_FILES+="$FILE"
            OUTPUT_FILES+=$'\n'
        fi
    done

    # Check if there is at last one file with valid mime type
    if ((VALID_FILES_COUNT == 0)); then
        if [ -n "$MIME_LIST" ]; then
            _msg_error "Error: There is no '$MIME_LIST' in the selected files!"
        else
            _msg_error "Error: There is no valid itens in the in the selected files!"
        fi
        return 1
    fi

    if [ -n "$MIN_FILES" ]; then
        if ((VALID_FILES_COUNT < MIN_FILES)); then
            _msg_error "Error: You selected $VALID_FILES_COUNT files, but the minium is $MIN_FILES!"
            return 1
        fi
    fi

    if [ -n "$MAX_FILES" ]; then
        if ((VALID_FILES_COUNT > MAX_FILES)); then
            _msg_error "Error: You selected $VALID_FILES_COUNT files, but the maximum is $MAX_FILES!"
            return 1
        fi
    fi

    echo "$OUTPUT_FILES" | grep -v "^$" | sort -V
    return 0
}

_transfer_file() {
    local TRANSFER_FLAG="$1"
    # TRANSFER_FLAG values:
    # "m": Move/rename.
    # "c": Copy.
    local FILE_SRC="$2"
    local FILE_DST="$3"
    local EXIT_CODE=0

    # Avoid problems with 'mv' command without the path
    if ! [[ "$FILE_SRC" == "/"* ]] && ! [[ "$FILE_SRC" == "./"* ]]; then
        FILE_SRC="./$FILE_SRC"
    fi
    if ! [[ "$FILE_DST" == "/"* ]] && ! [[ "$FILE_DST" == "./"* ]]; then
        FILE_DST="./$FILE_DST"
    fi

    # Avoid transfer a file to the same name
    if [ "$FILE_SRC" = "$FILE_DST" ]; then
        return 0
    fi

    # Avoid overwrite a file
    if [ -a "$FILE_DST" ]; then
        echo "It was not possible to transfer '$FILE_SRC' because there is already a file with the same name in '$FILE_DST'."
        return 1
    fi

    # Run the main process
    case "$TRANSFER_FLAG" in
    "m")
        mv -n "$FILE_SRC" "$FILE_DST"
        EXIT_CODE=$?
        ;;
    "c")
        cp -a -n "$FILE_SRC" "$FILE_DST"
        EXIT_CODE=$?
        ;;
    *)
        echo "Wrong parameters for '_transfer_file'."
        return 1
        ;;
    esac

    # Check if the file has transfered
    if [ "$EXIT_CODE" -eq 0 ] && ! [ -a "$FILE_SRC" ] && [ -a "$FILE_DST" ]; then
        echo "Transfered '$FILE_SRC' to '$FILE_DST'."
    fi

    return "$EXIT_CODE"
}

_parallel_run() {
    local INPUT_FILES="$1"
    local NUM_PROC=0
    local i=0

    NUM_PROC=$(nproc --all)

    (
        for FILE in $INPUT_FILES; do
            ((i = i % NUM_PROC))
            ((i++ == 0)) && wait

            _run_task "$FILE" "$OUTPUT_DIR" &
        done
        wait
    )
}
