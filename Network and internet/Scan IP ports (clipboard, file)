#!/usr/bin/env bash

# Source the script 'common-functions.sh'.
SCRIPT_DIR=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &>/dev/null && pwd)
ROOT_DIR=$(grep --only-matching "^.*scripts[^/]*" <<<"$SCRIPT_DIR")
source "$ROOT_DIR/common-functions.sh"

_main() {
    local input_files=""
    local output_dir=""

    # Execute initial checks.
    if [[ -n "${XDG_SESSION_TYPE+x}" ]] &&
        [[ "${XDG_SESSION_TYPE,,}" == "wayland" ]]; then
        _check_dependencies "command=nmap | command=wl-paste; package=wl-clipboard"
    else
        _check_dependencies "command=nmap | command=xclip"
    fi

    _display_wait_box "2"
    input_files=$(_get_files "par_type=all; par_get_pwd=true")

    # Export functions to be used inside new shells (when using 'xargs').
    export -f _resolve_host

    # Execute the function '_main_task' for each file in parallel.
    _run_task_parallel "$(_prepare_input "$input_files")" "$output_dir"

    local std_output=""
    std_output=$(_storage_text_read_all)

    _display_text_box "$std_output"
}

_main_task() {
    local input_file=$1
    local output_dir=$2
    local std_output=""
    local timeout_value="5"
    local status="ðŸŸ¡"
    local hostname=""

    # Run the main process.
    std_output=$(LC_ALL=C nmap -n -Pn -T4 --max-retries 1 --host-timeout "$timeout_value"s "$input_file" 2>/dev/null)

    # shellcheck disable=SC2001
    std_output=$(grep --extended-regexp "^[0-9]+/(tcp|udp)\b" <<<"$std_output" || true)

    if [[ -z "$std_output" ]]; then
        std_output="(None)"
        status="ðŸ”´"
    elif [[ "$std_output" == *" open "* ]]; then
        status="ðŸŸ¢"
    fi

    hostname=$(_resolve_host "$input_file")
    if [[ -n "$hostname" ]]; then
        hostname=" ($hostname)"
    fi

    _storage_text_write_ln "$status IP: $input_file$hostname"$'\n'"$std_output"$'\n'
}

_extract_ips() {
    local data=$1

    if [[ -z "$data" ]]; then
        return
    fi

    data=$(grep --only-matching --perl-regexp '\b(?:(?:25[0-5]|2[0-4]\d|1?\d?\d)\.){3}(?:25[0-5]|2[0-4]\d|1?\d?\d)\b' <<<"$data")
    data=$(sort --unique <<<"$data")

    printf "%s" "$data"
}

_prepare_input() {
    local input_files=$1
    local item_1=""
    local file_data=""
    local clipboard_data=""
    local ips=""

    # Check if the input is a file or a directory. If it is a directory,
    # get the IPs from the clipboard.
    item_1=$(cut -d "$FIELD_SEPARATOR" -f 1 <<<"$input_files")
    if [[ ! -d "$item_1" ]]; then
        # shellcheck disable=SC2086
        file_data=$(cat -- $input_files 2>/dev/null)
        ips=$(_extract_ips "$file_data")
    fi

    # If there are no valid IPs in the file(s),
    # get the IPs from the clipboard.
    if [[ -z "$ips" ]]; then
        clipboard_data=$(_get_clipboard_data)
        ips=$(_extract_ips "$clipboard_data")
    fi

    if [[ -z "$ips" ]]; then
        _display_error_box "There are no valid IPs in the clipboard or in the selected file(s)!"
        _exit_script
    fi

    _convert_text_to_delimited_string "$ips"
}

_resolve_host() {
    local ip=$1
    local hostname=""

    # Try local resolution (via /etc/hosts, NSS, etc.).
    hostname=$(getent hosts "$ip" | awk '{print $2}' | head -n1)

    if [[ -n "$hostname" ]]; then
        printf "%s" "$hostname"
        return 0
    fi

    # If not found locally, try online resolution.
    if _command_exists "host"; then
        hostname=$(host "$ip" | awk '/domain name pointer/ {print $5}')
    elif _command_exists "dig"; then
        hostname=$(dig -x "$ip" +short)
    fi

    # shellcheck disable=SC2001
    hostname=$(sed "s|\.$||" <<<"$hostname")

    printf "%s" "$hostname"
}

_main "$@"
